<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在线图片转 ico]]></title>
    <url>%2F2018%2F08%2F07%2Ficon%2F</url>
    <content type="text"><![CDATA[在线图片转换 ico 地址(https://lvwenhan.com/convertico/) 相当好用的一个在线转换器]]></content>
      <tags>
        <tag>ico</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Redux 入门]]></title>
    <url>%2F2018%2F08%2F07%2Fredux%2F</url>
    <content type="text"><![CDATA[React Redux 入门React 数据管理工具 本篇文章中以 create-react-app 脚手架搭建项目为例 什么时候使用 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态（一般指非父子组件） 注意： Redux 会导致项目结构变的更复杂，因此非必要，尽量还是别使用 Redux 如何使用store：Redux 用来保存数据的一个对象dispatch：Redux 用来改变 store 数据的方法state：Redux 中现在储存的 store 数据 store 无法直接改变自身状态，需要调用对应的 dispatch 方法发送一个 action 来改变数据因此需要一个中间件来保证 Redux 的正常执行 在 react 中使用首先需要在根组件 App 中创建 store，通过 Provider 将 store 挂载到全局 清理无用内容 React 中常用的中间件为 redux-thunk 1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;/* redux */import &#123; createStore, applyMiddleware, compose &#125; from &apos;redux&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import thunk from &apos;redux-thunk&apos;;/* 写好的redux */import rootReducer from &apos;./reduxs/index.js&apos;;import Demo from &apos;./component/demo.jsx&apos;;/* 创建store */const store = createStore( rootReducer, compose( applyMiddleware(thunk) // 中间件 ));class App extends Component &#123; render() &#123; return ( /* 传递 store */ &lt;Provider store=&#123;store&#125;&gt; &lt;Demo /&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; 在要用数据的组件中通过 connect 暴露组件 1234567891011121314151617181920212223242526272829import * as React from &apos;react&apos;;import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; change_title &#125; from &apos;../reduxs/demo.js&apos;; class Demo extends React.Component&#123; render()&#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;p&gt; &#123;this.props.title&#125; &lt;/p&gt; &lt;button onClick=&#123; () =&gt; this.props.change_title(&apos;piu&apos;)&#125; &gt; piu &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;const mapPropsToState = state =&gt; (&#123; state, title: state.demo.title&#125;);const mapDispatchToState = dispatch =&gt; (&#123; change_title: title =&gt; dispatch(change_title(title))&#125;);export default connect(mapPropsToState, mapDispatchToState)(Demo); 控制 redux 中 store 的一般单独创建文件存放 reduxs/index.js1234567import &#123; combineReducers &#125; from &apos;redux&apos;;import demo from &apos;./demo.js&apos;;export default combineReducers(&#123; demo&#125;); 每个组件的数据可以分别存放 例如 demo.js1234567891011121314151617181920212223242526272829// init stateconst initialState = &#123; title: &apos;测试标题&apos;&#125;;const TITLE = &apos;demo/change_title&apos;;export function change_title(title)&#123; return (dispatch: Function) =&gt; &#123; dispatch(&#123; type: TITLE, title &#125;); &#125;;&#125;// redux reducerexport default (state: Object = initialState, action: Action) =&gt; &#123; switch (action.type) &#123; case TITLE: return &#123; ...state, title: action.title &#125;; default: return state; &#125;&#125;; 这样一个完整的数据结构创建完成了 最终文件目录如下 完整Demo]]></content>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 绑定独立域名]]></title>
    <url>%2F2018%2F08%2F07%2Fdomain%2F</url>
    <content type="text"><![CDATA[github 绑定独立域名 购买域名, 添加解析我的域名从阿里云购买的，以阿里云为例说明流程 在阿里云域名服务购买自己喜欢的域名链接 在阿里云控制台云解析 DNS 添加记录 解析自己的博客地址 三个位置依次选中 CNAME www 博客地址 重复操作添加 CNAME @ 博客地址 使用 github 博客页面可以参考 链接 非阿里云购买的域名解析 控制台域名管理 添加自己购买的域名 在自己购买域名的平台修改 DNS dns12.hichina.com dns11.hichina.com 控制台云解析 DNS 步骤同上 添加 github 重定向在博客根目录下添加文件 CNAME，文件内写入域名注意： 文件没有后缀名 写入内容仅域名地址 例如：kenghuo.ink 或者在 github 仓库 setting 中 Github Page 添加设置 Custom domain 添加域名]]></content>
      <tags>
        <tag>Github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2018%2F08%2F03%2Fworker%2F</url>
    <content type="text"><![CDATA[web worker 的使用 JS 为单线程, 一些计算量较大的代码肯定会影响整体程序的执行速度,而且, 多核计算机的性能也无法高效利用,为了解决这些问题, HTML5 提出 Web Worker , 可以使 JS 一些可以同时进行的事件放在独立的小线程中执行 使用限制在 worker 子线程中，可以获得下列对象 navigator对象 location对象，只读 这里不能进行 location 赋值实现页面跳转！！！ XMLHttpRequest对象 ajax 请求 setTimeout/setInterval方法 Application Cache 通过importScripts()方法加载其他脚本 创建新的Web Worker worker线程不能获得下列对象 DOM对象 window对象 document对象 parent对象 使用主线程使用 new 新建一个子线程, 参数为线程文件Worker1var worker = new Worker(&apos;work.js&apos;); 调用 postMessage 方法向子线程传递消息通过 onmessage 监听子线程发送的消息 onerror 监听错误信息 123456789101112worker.postMessage(&#123;name:&apos;Kenghuo&apos;, title: &apos;Hello&apos;&#125;);worker.onmessage = function(event)&#123; console.log(event); document.getElementById(&apos;title&apos;).innerHTML = event.data;&#125;worker.onerror = function(error)&#123; console.log(error);&#125; 子线程 新建的 work.js 文件 通过 onmessage 来接收主线程发送的消息通过 postMessage 发送处理完成后的信息通过 importScript 引入别的 JS 文件 1234567importScript(&apos;func.js&apos;);onmessage = (event) =&gt; &#123; console.log(event); postMessage(add(event.data.title + &apos; &apos; + event.data.name));&#125; demo]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键分享]]></title>
    <url>%2F2018%2F08%2F02%2Fshare%2F</url>
    <content type="text"><![CDATA[一键分享 一键分享的代码 复制这段代码到希望分享的网页, 即可实现一键分享功能12345678910111213141516171819202122window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: [&quot;tsina&quot;, &quot;weixin&quot;, &quot;mail&quot;, &quot;linkedin&quot;, &quot;copy&quot;, &quot;print&quot;], &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;0&quot;, &quot;bdSize&quot;: &quot;32&quot; &#125;, &quot;slide&quot;: &#123; &quot;type&quot;: &quot;slide&quot;, &quot;bdImg&quot;: &quot;3&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125;&#125;;with(document) 0[ (getElementsByTagName(&apos;head&apos;)[0] || body) .appendChild(createElement(&apos;script&apos;)) .src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)]; 注意： JavaScript 严格模式不支持 with 关键字, 需要修改代码 1234567891011121314151617181920window._bd_share_config = &#123; &apos;common&apos;: &#123; &apos;bdSnsKey&apos;: &#123;&#125;, &apos;bdText&apos;: &apos;&apos;, &apos;bdMini&apos;: &apos;1&apos;, &apos;bdMiniList&apos;: [&apos;tsina&apos;, &apos;weixin&apos;, &apos;mail&apos;, &apos;linkedin&apos;, &apos;copy&apos;, &apos;print&apos;], &apos;bdPic&apos;: &apos;&apos;, &apos;bdStyle&apos;: &apos;0&apos;, &apos;bdSize&apos;: &apos;32&apos; &#125;, &apos;slide&apos;: &#123; &apos;type&apos;: &apos;slide&apos;, &apos;bdImg&apos;: &apos;3&apos;, &apos;bdPos&apos;: &apos;right&apos;, &apos;bdTop&apos;: &apos;100&apos; &#125;&#125;// 这里不支持 with 关键字的代码document.getElementsByTagName(&apos;head&apos;)[0].appendChild(document.createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5) 官方百度分享]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 和 github 创建博客最简单粗暴的方法]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo-init%2F</url>
    <content type="text"><![CDATA[在 github 上 使用 hexo 创建博客最简单粗暴的方法 最简单粗暴创建博客的方法 注册账户 注册 github 账号注册地址 新建个人仓库 打开 github page详情见搭建博客 注册账号之后，需要添加SSH Key使用 git 管理代码需要这东西 安装程序 安装 nodejs 下载地址没有特殊要求直接安装一直下一步就行 安装 hexo 在安装 nodeJS 之后，可以使用 npm 包管理器 安装 hexo 1$ npm install hexo hexo-cli -g # 全局安装 hexo 安装 git 下载地址根据需要安装对应版本的 git安装成功之后，右键单击出现 Git Bash Here 以及 Git GUI 说明成功 使用 hexo找个空文件夹直接1$ hexo init 在 hexo init 完成后记得安装包 hexo-deployer-git包1$ npm install hexo-deployer-git --save 修改配置文件 _config.yml123456url: https://github.com/github用户名 # 提交的账户名deploy: type: git repo: https://github.com/github用户名/github用户名.github.io # 提交的仓库 branch: master 配置完成后，依次键入以下命令提交123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo deploy # 提交文件到指定 github 仓库 在本地预览当前博客效果本地123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo server # 开启本地服务器 4000 端口号 浏览器 localhost:4000 可以看到当前博客生成内容]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常见麻烦]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo 使用过程中遇到的麻烦 没反应命令行键入 hexo d 毫无反应 原因: 缺少包 hexo-deployer-git hexo 从版本 2.x.x 升级到 3.x.x 删除了内置的 git 包需要单独安装 hexo-deployer-git 包 原因: 配置文件 url 以及 deploy 未配置123456url: https://github.com/username # 这里是提交的账户deploy: type: git repo: https://github.com/username/username.github.io # 这里是提交仓库的地址 branch: master]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2018%2F07%2F26%2Fgit%2F</url>
    <content type="text"><![CDATA[git 常用命令 clone克隆或者叫下载, 将远程服务器上的仓库文件下载到本地 12git clone git@gitee.com:xxx `&lt;dirName&gt;` git clone https://gitee.com/xxx `&lt;dirName&gt;` 将仓库 git@gitee.com:xxx 中的文件下载到本地 ./dirName 目录下将仓库 https://gitee.com/xxx 中的文件下载到本地 ./dirName 目录下 两个命令的区别在于 使用 SSH 下载的内容提交不需要登录名以及密码注意：不论哪个 git 命令提交代码都需要 SSH公匙 验证 SSH Key查看公钥 12$ cd ~/.ssh # 进入指定文件夹 $ ls # 查看文件夹下的文件 存在这两个文件文件1id_rsa id_rsa.pub 文件 id_rsa.pub 储存当前生成的随机数公钥 否则生成公钥1234$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot;$ ssh-keygen -t rsa -C &quot;youremail&quot;连续3个回车 在 github 设置生成的公钥执行命令1ssh git@github.com 出现文字123PTY allocation request failed on channel 0Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 设置公钥成功 push将修改内容交于 git 控制12$ git add . # 提交全部修改的文件$ git add xxx # 提交指定文件 将提交的修改添加到缓冲区1$ git commit -m &apos;xxx&apos; # xxx 提交的注释性内容 上传提交的修改1$ git push origin &lt;branchName&gt; # 提交指定分支的修改 branch 添加分支 git branch &lt;newBranchName&gt; 添加新分支 newBranchName新分支的改动不会影响原有分支的文件 注意切换分支之前对当前分支进行提交 (commit) 操作推送之前注意对应分支, 除了默认分支不需要以外, 其余分支提交 git push origin &lt;branchName&gt; 切换分支 git checkout &lt;branchName&gt; 切换到分支 branchName多个分支之间的文件不受彼此影响 合并分支修改 git merge &lt;branchName&gt; 将当前分支与 branchName 分支合并]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F07%2F24%2Fsort%2F</url>
    <content type="text"><![CDATA[几种排序算法 冒泡排序冒泡排序一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 123456789101112131415function bubbleSort(arr) &#123; let len = arr.length; console.time(&apos;原始冒泡排序时间&apos;); for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 let temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.timeEnd(&apos;原始冒泡排序时间&apos;); return arr;&#125; 优化标记已经完成的排序序号, 从未排序的位置开始进行排序, 减少内层循环次数 123456789101112131415161718function bubbleSort2(arr) &#123; let i = arr.length-1; //初始时,最后位置保持不变 console.time(&apos;优化冒泡排序时间&apos;); while ( i&gt; 0) &#123; let pos= 0; // 每趟开始时,无记录交换 for (let j = 0; j&lt; i; j++)&#123; if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 let tmp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; i = pos; // 为下一趟排序作准备 &#125; console.timeEnd(&apos;优化冒泡排序时间&apos;); return arr;&#125; 升级版冒泡排序从前向后同时进行排序操作, 记录排序序号 12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(&apos;2.改进后冒泡排序耗时&apos;); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) &#123; //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) &#123; //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;); return arr3;&#125; 选择排序选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415161718function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); // 计时开始 for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); // 计时结束 return arr;&#125; 插入排序插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 1234567891011121314function insertionSort(array) &#123; console.time(&apos;插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时：&apos;); return array;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期]]></title>
    <url>%2F2018%2F07%2F23%2Freact-lifecycle%2F</url>
    <content type="text"><![CDATA[React 生命周期 React v16.x.x 生命周期发生变化 React 生命周期 挂载阶段 # 更新阶段 # 卸载阶段 # 挂载阶段constructor(props) 初始化state 绑定this 通过super方法获取props1234567constructor(props)&#123; super(props); // 继承父组件 props this.state = &#123; // 初始化 state count: 1 &#125;; this.toggle = this.toggle.bind(this); // 内部方法绑定 this&#125; static getDerivedStateFromProps(props, state) 在调用 render 方法之前被调用，包括初始装载（mount）和后续更新时。 它应该返回一个更新 state(状态) 的对象，或者返回 null 不更新任何 state(状态)。12345678static getDerivedStateFromProps(props, state) &#123; if(props.user.id)&#123; return &#123; username: props.user.name &#125;; &#125; return null; // 这里必须返回对象 否则报错&#125; render() 生成虚拟 DOM123render()&#123; return &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;&#125; componentDidMount dom树挂载时执行的操作 插入 DOM 树时调用123componentDidMount()&#123; document.getElementById(&apos;#random) = &apos;/path.jsp&apos;; // 登录验证码 在虚拟 DOM 插入 DOM 树之后才能通过 JS 操作 DOM 结构&#125; 更新阶段componentDidUpdate(prevProps, prevState) dom 更新时调用, props 以及 state 发生改变都会调用该函数12345678componentDidUpdate(prevProps, prevState) &#123; if(this.props.user.id !== prevProps.user.id)&#123; // 这里setState 必须放在 条件判断中, 否则会发生死循环 console.log(&apos;又一个&apos;); this.setState(&#123; count: this.state.count++ &#125;); &#125;&#125; UNSAFE_componentWillReceiveProps(nextProps) props 发生改变调用函数 将来会被弃用, 尽量避免出现, 可以使用上述 钩子函数替代更新12345678UNSAFE_componentWillReceiveProps(nextProps) &#123; if(nextProps.user.id !== this.props.user.id)&#123; // 理由同上 console.log(&apos;又一个&apos;); this.setState(&#123; count: this.state.count++ &#125;); &#125;&#125; 卸载阶段componentWillUnmount() 组件将要卸载 卸载定时器、清理redux数据等等123componentWillUnmount() &#123; clearTimeout(this.timer);&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 遇到的坑]]></title>
    <url>%2F2018%2F07%2F20%2Freact-problem%2F</url>
    <content type="text"><![CDATA[曾经在React中踩过的大大小小的坑 曾经踩过的坑 更新状态12345678componentDidUpdate(prevProps, prevState)&#123; // 传递的id 发生改变时 修改当前组件状态 prevProps.id !== this.props.id &amp;&amp; this.setState(&#123; ... // 这里的状态修改必须要条件限制, 否则会陷入死循环 &#125;)&#125; state 的修改会触发这个钩子函数, 在这里设置 state , 修改状态会导致函数无限调用, 进入死循环 类似的还有 UNSAFE_componentWillReceiveProps 这个函数中不能修改 props , 触发 events up 事件, 需要进行条件限制 转义字符12345678constructor(props)&#123; super(props) this.state = &#123; title: &apos;测&amp;nbsp;&amp;nbsp;试&apos; &#125;&#125;&lt;p&gt;&#123;&#123;this.state.title&#125;&#125;&lt;/p&gt; 显示结果 1测&amp;nbsp;&amp;nbsp;试 这里字符串使用转义字符需要用到dangerouslySetInnerHTML 12345678constructor(props)&#123; super(props) this.state = &#123; title: &apos;测&amp;nbsp;&amp;nbsp;试&apos; &#125;&#125;&lt;p dangerouslySetInnerHTML=&#123;&#123;_html:this.state.title&#125;&#125; &gt;&lt;/p&gt; 这样才会正常显示title内容 1测 试]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2Fblog%2F</url>
    <content type="text"><![CDATA[搭建个人博客的方法 注册github账号注册地址 创建个人仓库登录账户之后 &gt; new repository(注意再次之前需要登录邮箱验证账户) &gt; 进入 Settings 找到 GitHub Pages &gt; choose a theme &gt; 之后再次进入 Settings 在 GitHub Pages 位置多出来 Your site is published at https://kenghuo.github.io/ 表示博客创建成功 点击链接可以进入当前博客 如果想要使用类似 https://kenghuo.github.io/ 这样的域名作为博客地址, 需要仓库名称与账号名称一致 否则的话你的博客地址会变成这样 https://kenghuo.github.io/akang.github.io/ 克隆代码到本地进入已经创建好的个人仓库 有个绿色的按钮 clone and download 可以使用git 或者直接下载压缩包 Download ZIP git clone https://github.com/kenghuo/kenghuo.github.io.git dirname 或者 git clone git@github.com:kenghuo/kenghuo.github.io.git dirname 都可以 dirname 为下载完成的文件夹名称 可以自定义 点击 Download ZIP 下载压缩包 解压缩也可以得到完整的项目 编译博客页面也可以通过HTML可以自定义页面 入口文件名称为 index.html 也可以通过 hexo 搭建页面hexo Github]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 基本语法]]></title>
    <url>%2F2018%2F07%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 语法 Markdown 是一种轻量级标记语言，这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）” 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。 英文参考文献(https://github.com/DavidAnson/markdownlint/blob/v0.10.0/doc/Rules.md)英文参考文献(https://daringfireball.net/projects/markdown/syntax) 中文参考文献(http://www.markdown.cn/)中文参考文献(https://github.com/younghz/Markdown) Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法 标题同 html h1 ~ h6 文字前加 # 个数表示标题大小, 越少越大(注意一级标题下存在下划线)此外, 一行文本之后添加 = 或者 - 也可以作为一级或者二级标题出现 符号数量任意 123456# 一级标题## 二级标题...###### 六级标题 123456一级标题===二级标题--- 列表有序列表数字加上 .(英文句号) 加个空格 即可构成有序列表数字可以随意写, markdown语法会自动调整为顺序编码 水果 苹果 香蕉 蔬菜 小麦 无序列表* - + . 加个空格 即可构成无序列表同级列表项前的符号保持一致下级子列表 仅需要缩进一格 测试1 测试1.1 测试1.1.1 测试1.2 测试1.3 测试2 测试3 插入url[ ] ( ) 两个符号构成 [ ] 描述性文字 ( ) 链接地址[ ] 放的是 a 标签里的文字信息 ( ) 路径地址同 html的 a 标签 1234567&lt;a href=&quot;https://www.baidu.com/&quot; title=&quot;类似 html 的title&quot; &gt;百度&lt;/a&gt; [百度](https://www.baidu.com/) 行内式[百度][baidu][baidu]:https://www.baidu.com/ &quot;类似 html 的title&quot; 参考式 可以放在任意位置 比如文本末尾处 效果 百度 百度 百度 插入图片! [ ] ( ) 这三个部分构成图片样式 !是加载图片的标志性符号[ ] 注释性文字 ( ) 图片路径 可以使用相对路径 也可以使用绝对路径 同 html 的 img 标签 12345&lt;img src=&quot;/img/&quot; alt=&quot;百度&quot; /&gt;![百度](/img/cat.png)![不存在的图片](#) 效果 粗体、斜体、删除线粗体：在文字前后添加 * 或者 __ (注意符号与文字间不要有空格, 开始标记和结尾标记一致)斜体：在文字前后添加 或者 _删除线：在文字前后添加 ~~ 12345678测试 正常文字样式测试 __粗体文字样式__测试 _斜体文字样式_测试 ~~删除线文字样式~~ 测试 正常文字样式 测试 粗体文字样式 测试 斜体文字样式 测试 删除线文字样式 引用在文字前面加上 &gt;引用支持嵌套 12345&gt; To do or not to do, this is a problem -- Shakespeare&gt; 这里是一级引用 &gt; &gt; 可以在后边嵌套.&gt; &gt; &gt; 甚至可以是多个嵌套等级. To do or not to do, this is a problem – Shakespeare 这里是一级引用 可以在后边嵌套. 甚至可以是多个嵌套等级. 表格两个 | 之间是一个单元格表头与表格主体之间通过 - (任意数量英文减号) 分割分割线单元格数量不少于行内单元格, 比如每行有三个单元格, 分割线大于等于三个行与行之间不要有空行 1234| 姓名 | 地址 | 标题 ||-|-|-|| 阿康 | kenghuo.github.io | markdown || 每行 | 单元格数量一样 | 不然就不是表格了 | 姓名 地址 标题 阿康 kenghuo.github.io markdown 每行 单元格数量一样 不然就不是表格了 代码块12345前后添加 __```__ 注意前边符号写完后需要换行因此可以不换行加上注释性内容, 而不会出现在代码块中 效果如下123for (let i = 0; i &lt; 10; i++)&#123; console.log(&quot;hello markdown!&quot;);&#125; 换行同一段落内换行, 可以在 需要换行的地方 两个空格 回车 段落换行, 需要文字之间出现空行 123456段落内部换行 (两个空格)换行段落1段落2 效果 段落内部换行换行 段落1 段落2]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>

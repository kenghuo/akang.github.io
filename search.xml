<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js中的this(转)]]></title>
    <url>%2F2019%2F06%2F04%2Fjs-this%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn1: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var fn1 = obj.fn1;fn1.call(null);obj.fn1();console.log(window.number); js 中的 this 机制解析 (๑•̀ㅂ•́)و✧。 嗨，你真的懂this吗？]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组api]]></title>
    <url>%2F2019%2F06%2F02%2Fjs-array-api%2F</url>
    <content type="text"><![CDATA[js 中的常用的数组 API Array.from() 创建数组 1Array.from(new Set([1, 2, 3])) Array.isArray() 判断是否为数组 12let arr = [1,2,3];Array.isArray(arr); pop 删除数组中最后一个元素 push 向数组最后一位添加一个元素 shift 删除数组中第一个元素 unshift 向数组中最开始添加一个元素 reverse 数组中所有元素倒序 sort 数组排序 splice 用新元素替换旧元素的方式来修改数组 copyWithin 使用数组内部元素替换指定元素参数依次为 需要替换的元素下标, 开始替换元素的下标, 替换元素的终止下标 12let arr1 = [1,2,3,4,5,6];let arr2 = arr1.copyWithin(1, 3, 4); // [1,4,3,4,5,6] 从下标1的元素开始替换, 使用的替换元素是该数组内的下标3, 结束为下标4 fill 将数组指定区间内的元素替换为某个值 12let array = [1,2,3,4,5];let array2 = array.fill(10,0,3); // [10, 10, 10, 4, 5] 把数组内下标0到下标3 所有元素替换为10 concat 合并两个数组 join 将数组内元素使用指定字符拼接 空值默认为 , slice 将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象 12var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];var array2 = array.slice(2,3); // [&apos;three&apos;] 下标2 下标3 截取出来 toString 类似 join 使用 , 拼接所有元素 toLocaleString 类似 toString indexOf 查找指定元素下标 不存在返回-1 lastIndexOf 查找指定元素最后一次出现的下标 includes 数组是否存在元素 返回 boolean 值 forEach 循环数组 every 使用传入的函数测试所有元素，只要其中有一个函数返回值为 false，那么该方法的结果为 false；如果全部返回 true，那么该方法的结果才为 true 12let arr = [1,2,3,4,5];arr.every(val =&gt; val &lt; 6) some 测试数组元素时，只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false 12let arr = [1,2,3,4,5];arr.some(val =&gt; val &gt; 3); filter 使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组 12let arr = [1,2,3,4,5];arr.filter(val =&gt; val &gt; 3 &amp;&amp; val &lt; 5); map 循环遍历数组 与 forEach 的区别仅是是否返回内容组成新的数组 reduce 累加器 1234let array = [1, 2, 3, 4];let s = array.reduce(function(previousValue, value, index, array)&#123; return previousValue * value;&#125;,1); // 数组中每个值按照 给定函数进行累计计算 这里是乘算 reduceRight 方法类似 reduce 计算顺序从右向左 entries 返回一个数组迭代器对象，该对象包含数组中每个索引的键值对 123456let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];let iterator = array.entries();console.log(iterator.next().value); // [0, &quot;a&quot;]console.log(iterator.next().value); // [1, &quot;b&quot;]console.log(iterator.next().value); // [2, &quot;c&quot;]console.log(iterator.next().value); // undefined find find() 方法基于ECMAScript 2015（ES6）规范，返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回undefined。 findIndex findIndex() 方法则返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。 keys 返回键 12345var array = [&quot;abc&quot;, , &quot;xyz&quot;];var sparseKeys = Object.keys(array);var denseKeys = [...array.keys()];console.log(sparseKeys); // [&quot;0&quot;, &quot;2&quot;]console.log(denseKeys); // [0, 1, 2] values 类似 keys 返回值 12345var array = [&quot;abc&quot;, , &quot;xyz&quot;];var sparseKeys = Object.values(array);var denseKeys = [...array.values()];console.log(sparseKeys); // [&quot;abc&quot;, &quot;xyz&quot;]console.log(denseKeys); // [&quot;abc&quot;, undefined, &quot;xyz&quot;]]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的typeof]]></title>
    <url>%2F2019%2F06%2F02%2Fjs-typeof%2F</url>
    <content type="text"><![CDATA[js 中的 typeof 函数 typeof 基本类型: 除了 null 以外均可以返回进本类型本身对应的数据类型 引用类型: 除了 function 以外均返回 object 123456789101112131415161718192021222324252627282930313233343536373839404142// number 类型let num = 123;console.log(typeof num) // number// string 类型let str = &apos;123&apos;;console.log(typeof str) // string// boolean 类型var boo =true;console.log(typeof boo);// boolean// undefined类型var und ;console.log(typeof und);// undefined// null类型var nul =null;console.log(nul); // object// 可以得出：基本数据类型返回的是自己对应的类型 除了null, null 表示空对象// 复杂数据类型// Array类型var arr = new Array();console.log(typeof arr); // object // function类型var fn = function()&#123;&#125;;console.log(typeof fn); // function// Object类型var obj = new Object();console.log(typeof obj); // object// 字面量的数组var arr2 = [1,32];console.log(typeof arr2);// object// 自定义对象function Person(name)&#123; this.name =name;&#125;var stu = new Person();console.log(typeof stu); // object]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>typeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步操作]]></title>
    <url>%2F2019%2F05%2F16%2Fjs-asyn%2F</url>
    <content type="text"><![CDATA[这篇文章主要内容就是总结下 JavaScript 中的异步操作。 异步javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念——任务队列。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。于是JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 具体来说，异步运行机制如下： （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 实现1.回调函数123456789101112131415function callback(res) &#123; consolo.log(res);&#125;function foo(callback)&#123;//定义函数的时候将另一个函数（回调函数）作为参数传入定义的函数中。 var xhr=new XMLHttpRequest(); xhr.onload=function()&#123; callback(this.responseText); &#125;; xhr.onerror=reject; xhr.open(&apos;GET&apos;,url); xhr.send();&#125;foo(callback); 2.Promise123456789101112131415function ajax(url)&#123; return new Promise(function(resolve,reject)&#123; var xhr=new XMLHttpRequest(); xhr.onload=function()&#123; resolve(this.responseText); &#125;; xhr.onerror=reject; xhr.open(&apos;GET&apos;,url); xhr.send(); &#125;);&#125;ajax(&apos;/echo/json&apos;) .then(function(result)&#123;...&#125;) .then(function()&#123;...&#125;) .catch(function()&#123;...&#125;); 3.async123456async function getUserInfo(user) &#123; let promise = await fetch(`https://api.github.com/users/$&#123;user&#125;`); return user ? promise.json() : &apos;查谁给个话，别不说啊！&apos;;&#125;getUserInfo(&apos;kenghuo&apos;).then(res =&gt; console.log(res)) 参考文档 js中的同步和异步的个人理解 作者：YinghaoGuo]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 数据类型]]></title>
    <url>%2F2019%2F05%2F15%2Fjs-type%2F</url>
    <content type="text"><![CDATA[很多内容都是零零散散的，把之前学的用的JavaScript相关内容整理下。对自己之前的学习做个系统的整理这篇文章主要是总结下JavaScript中的数据类型 js数据类型1.基本类型基本类型的复制就是在栈内存中开辟出了一个新的存储区域用来存储新的变量，这个变量有它自己的值，只不过和前面的值一样，所以如果其中一个的值改变，则不会影响到另一个。Undefined、Null、Number、String、Boolean 以及 es6 提出的 Symbol 总共 6 种基本数据类型 Undefined 变量已经声明，未赋值时该变量为 undefined Null 特指对象的值未设置注意： 这里的 Null 特指对象已声明未赋值，因为一些遗留原因才作为基本类型之一的 Number 数字类型 String 字符串类型 Boolean 布尔类型，枚举值 true false Symbol es6提出的新数据类型，类似于 String 类型，为了避免变量名冲突提出的一种新数据类型 2.引用类型定义了一个对象其实是在栈内存中存储了一个指针，这个指针指向堆内存中该对象的存储地址。复制给另一个对象的过程其实是把该对象的地址复制给了另一个对象变量，两个指针都指向同一个对象，所以若其中一个修改了，则另一个也会改变。Object、Array、Set、Map、WeakSet、WeakMap等 Object 对象 Array 对象 Set 类似无重复数值的数组 Map 成员名称可以为对象的对象 WeakSet 类似 Set 但是成员只能为对象 Map 类似 Map 同样的成员只能为对象 栈内存和堆内存为什么会有栈内存和堆内存之分？通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。 具体代码基本类型123456789101112131415let und;let str = &apos;string&apos;;let num = 1;let bool = true;let sym = Symbol(&apos;this is a symbol&apos;);typeof undtypeof strtypeof numtypeof booltypeof symlet str1 = str;str1 += &apos; change&apos;;console.log(str1); // &apos;string change&apos;console.log(str); // &apos;string&apos; 基本类型变量赋值会将值传递给新变量，新变量值变化不会影响原有变量 引用类型12345678let num = Symbol(&apos;num&apos;);let obj = &#123; [num]: 1&#125;;let obj1 = obj;obj1.num = 2;console.log(obj.num); // 2 引用类型会在堆内存里存储数据，栈内存保存的是指针，赋予新变量时，将指针赋值，修改新变量的值，堆内存中数据发生变化，原有变量也就会发生变化。 参考内容1.栈内存和堆内存 作者：juzipchy;2.ECMAScript 6 入门 作者：阮一峰]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git_command]]></title>
    <url>%2F2019%2F05%2F14%2Fgit-command%2F</url>
    <content type="text"><![CDATA[git 命令集合 $ git clone url dirname #克隆远程版本库 dirname可选 克隆代码到指定dirname目录$ git init dirname #初始化本地版本库 同上 $ git status #查看状态$ git diff #查看变更内容$ git add . #跟踪所有改动过的文件$ git add file #跟踪指定的文件 $ git mv oldnew #文件改名$ git rmfile #删除文件$ git rm –cachedfile #停止跟踪文件但不删除$ git commit -m “commit messages” #提交所有更新过的文件$ git commit –amend #修改最后一次改动 $ git reset HEAD filename # 放弃提交到缓存区的指定文件$ git reset . # 放弃所有添加到缓存区的文件 $ git log #查看提交历史$ git log -p file #查看指定文件的提交历史$ git blame file #以列表方式查看指定文件的提交历史 $ git reset –hard HEAD #撤销工作目录中所有未提交文件的修改内容$ git checkout HEAD file #撤销指定的未提交文件的修改内容$ git revert commit #撤销指定的提交$ git log –before=”1 days” #退回到之前1天的版本 $ git branch #显示所有本地分支.$ git checkout -b branchname origin/branchname #创建远程分支到本地 并切换到该分支$ git checkout branch/tag #切换到指定分支和标签$ git branch new-branch #创建新分支$ git branch -d branch #删除本地分支$ git tag #列出所有本地标签$ git tag tagname #基于最新提交创建标签$ git tag -d tagname #删除标签 $ git merge branch #合并指定分支到当前分支$ git rebase branch #衍合指定分支到当前分支 $ git remote -v #查看远程版本库信息$ git remote show remote #查看指定远程版本库信息$ git remote add remote url #添加远程版本库$ git fetch remote #从远程库获取代码$ git pull remote branch #下载代码及快速合并$ git push remote branch #上传代码及快速合并$ git push remote :branch/tag-name #删除远程分支或标签$ git push –tags #上传所有标签 git 小乌龟 下载地址 Windows git可视化工具 放弃本地修改代码 未使用 git add 缓存代码时。 可以使用 git checkout – filepathname (比如： git checkout – readme.md ，不要忘记中间的 “–” ，不写就成了检出分支了！！)。放弃所有的文件修改可以使用 git checkout . 命令。 已经使用了 git add 缓存了代码。 可以使用 git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，放弃所以的缓存可以使用 git reset HEAD . 命令。 已经用 git commit 提交了代码。 可以使用 git reset –hard HEAD^ 来回退到上一次commit的状态。此命令可以用来回退到任意版本：git reset –hard commitid 右键单击链接另存为可以下载地址 其他资料1.git四个阶段的修改和撤销]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 遇到的问题]]></title>
    <url>%2F2018%2F09%2F07%2Freact-problem%2F</url>
    <content type="text"><![CDATA[使用 React 中遇到的一些问题 dva 编译样式文件会生成后缀 class 无法正确匹配demo.less1234.demo&#123; color: red; font-size: 1.6rem;&#125; 1234.demo_sanc&#123; color: red; font-size: 1.6rem;&#125; 本意是为各个组件之间形成独立的样式，避免命名冲突 但是对于需要重复使用的组件 dom 结构因为 class 无法匹配导致样式缺失 123456:global&#123; .demo&#123; color: red; font-size: 1.6rem; &#125;&#125; 将样式添加到全局，编译不会添加后缀 Object.assignassign 是 ES6 提出的新特性，可以合并 JavaScript 对象注意: assign 是浅克隆 使用 Router 或者 state 时注意需要新建个对象地址 以免无法触发组件更新 componentDidUpdate 钩子函数 create-react-app打包地址默认为绝对路径(即服务器根目录)使用相对路径可以在 package.json 添加 homepage 为 . 打包之后的文件请求路径为相对路径 123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;react-demo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;homepage&quot;: &quot;.&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;bootstrap&quot;: &quot;^4.1.3&quot;, &quot;react&quot;: &quot;^16.4.2&quot;, &quot;react-dom&quot;: &quot;^16.4.2&quot;, &quot;react-redux&quot;: &quot;^5.0.7&quot;, &quot;react-router-dom&quot;: &quot;^4.3.1&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot;, &quot;reactstrap&quot;: &quot;^6.4.0&quot;, &quot;redux&quot;: &quot;^4.0.0&quot;, &quot;redux-logger&quot;: &quot;^3.0.6&quot;, &quot;redux-thunk&quot;: &quot;^2.3.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;&#125; BroswerRouter 使用二级目录无法访问需要在 BrowserRouter 中设置 basename 和二级目录名称一致可以完成访问 1234567&lt;BrowserRouter basename=&apos;/Demo&apos; &gt; &lt;!-- 注意这里的 basename 和部署项目的二级目录一致 该项目部署地址在服务器根目录 Demo 文件夹下 --&gt; &lt;div&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt; &lt;Route path=&quot;/index&quot; component=&#123;Index&#125;/&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 详细 demo 看这里]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 入门]]></title>
    <url>%2F2018%2F08%2F16%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack 入门读物 初次接触 webpack 安装依赖初始化项目1$ npm init -yes 生成 package.json 文件注意：文件目录为 webpack 会无法安装 webpack 依赖，需要修改 package.json 文件中 name 字段 全局以及文件夹内部安装 webpackwebpack 4.X 以后构建工具单独 需要单独安装 webpack-cli12$ npm install webpack webpack-cli -g$ npm install webpack webpack-cli -save-dev 注意：json 文件不支持注释，在使用时删除注释内容123456789101112131415161718&#123; &quot;name&quot;: &quot;webpack-demo&quot;, # 默认生成的是当前文件夹目录名称 为避免webpack安装冲突修改为 webpack-demo &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;webpack-cli&quot;: &quot;^3.1.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.16.5&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 使用创建需要打包的测试文件结构如下 app main.js module.js module.js123456// moudle.jsmodule.exports = function () &#123; let div = document.createElement(&apos;div&apos;); div.textContent = &quot;Hi there and greetings!&quot;; return div;&#125;; main.js123import Div from &apos;./module&apos;;document.getElementById(&apos;app&apos;).appendChild(Div()); 创建 webpack 配置文件 webpack.config.js12345678910module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, 入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; //打包后输出文件的文件名 &#125;, module: &#123; rules: [] &#125;&#125; 执行命令1$ webpack --config webpack.config.js --mode development 可以看到 dist 目录下生成 bundle.js 为了避免每次打包需要使用上述大串命令可以在 package.json 中设置命令scripts 字段添加字段1&quot;start&quot;: &quot;webpack --config webpack.config.js --mode development&quot; 这里设置完成的 package.json123456789101112131415161718192021&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: &#123; &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;style-loader&quot;: &quot;^0.22.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.16.5&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack --config webpack.config.js --mode development&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 之后可以使用1$ npm run start 执行打包过程 监听可以在 webpack 命令中添加 --watch 字段实现打包文件监听效果 1&quot;start&quot;: &quot;webpack --config webpack.config.js --mode development --watch&quot; 打包文件修改实时刷新 打包html插件 app 文件夹下新建 html 提供 title、meta 等信息，插件会按照这个文件作为模板生成新的 html 文件到指定文件夹1$ npm install html-webpack-plugin --save 1234567const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);plugins: [ new HtmlWebpackPlugin(&#123; // html引用自动插入 filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;),] 配置后的 webpack.config.js123456789101112131415161718const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, //入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; // 打包后输出文件的文件名 &#125;, module: &#123; rules: [] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;) ]&#125; dist 下生成的 html 文件中自动调整引用的 js 文件名称 打包cssapp 文件夹下新建文件 main.css123456#app &#123; border: 1px solid #eee; background: #333; color: #ddd; padding: .5rem 1rem;&#125; main.js 文件内引入 main.css 样式表1import &apos;./main.css&apos;; 打包会报错123ERROR in ./app/main.css 1:0Module parse failed: Unexpected character &apos;#&apos; (1:0)You may need an appropriate loader to handle this file type. 可以通过 style-loader 和 css-loader 实现 css 文件的打包安装依赖1$ npm install style-loader css-loader --save webpack.config.js 文件设置 css 打包规则123456rules: [ &#123; test: /\.css$/, // 正则匹配所有css文件 loader: [&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;] 再次执行打包命令 可以看打包文件中引入了 css 样式表 css文件单独打包如果想将 css 文件单独打包出来可以使用插件 mini-css-extract-plugin注意：webpack 4 只能使用这个了，之前的插件 extract-text-webpack-plugin不好使了1234567891011121314151617181920212223const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123;&#125; &#125;,&#123; loader: &apos;css-loader&apos;, options: &#123;&#125; &#125; ] &#125; ]&#125;plugins: [ new MiniCssExtractPlugin(&#123; // css单独分离 filename: &quot;[name].css&quot; &#125;),] 配置完成的 webpack.config.js123456789101112131415161718192021222324252627282930313233343536const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);module.exports = &#123; entry: __dirname + &apos;/app/main.js&apos;, //入口文件 output: &#123; path: __dirname + &apos;/dist&apos;, //打包后的文件存放的目录 filename: &apos;bundle.js&apos; //打包后输出文件的文件名 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123;&#125; &#125;,&#123; loader: &apos;css-loader&apos;, options: &#123;&#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // html引用自动插入 filename: &apos;index.html&apos;, template: &apos;app/index.html&apos; &#125;), new MiniCssExtractPlugin(&#123; // css单独分离 filename: &quot;[name].css&quot;, &#125;), ]&#125; 运行打包命令 npm run start 可以看到在 dist 文件夹下生成的 main.css 压缩 css 代码 插件 optimize-css-assets-webpack-plugin 用来压缩 css 代码文档123456789new OptimizeCssAssetsPlugin(&#123; cssProcessorOptions: &#123; mergeLonghand: false, discardComments: &#123; removeAll: true &#125; &#125;, canPrint: true,&#125;), sass 编译安装 sass-loader 和 node-sass1234567891011121314&#123; test: /\.scss$/, use: [ &#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: MiniCssExtractPlugin.loader // css 代码单独分离 &#125;, &#123; loader: &apos;css-loader&apos; &#125;, &#123; loader: &apos;sass-loader&apos; &#125; ]&#125; 需要代码的话可以看这里的 demo]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占位图片]]></title>
    <url>%2F2018%2F08%2F15%2Fimg%2F</url>
    <content type="text"><![CDATA[占位图片 https://placeholdit.imgix.net/~text?txtsize=30&amp;txt=1920x680&amp;w=1920&amp;h=680 txtsize: 字体大小txt: 文字内容w: 宽h: 高 这个网址可以生产站位图片调整大小图片文字等]]></content>
      <tags>
        <tag>img</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 入门]]></title>
    <url>%2F2018%2F08%2F09%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp 入门gulp 使用 nodejs 实现前端代码自动化的工具，与此类似的库也存在很多，目前主流库为 gulp 以及 webpack 这篇文章对于 gulp 做个简单的入门介绍 gulp 是一种自动化构建工具 安装依赖1$ npm install gulp --save 基本使用gulp 主要通过 task 来实现任务流程, 可以使用 pipe 传递每个步骤处理完成后的结果 在根目录新建文件夹 csscss 文件夹下新建文件 test.css这里的根目录是指 gulpfile.js 所在目录 测试12345html,body &#123; width: 100%; height: 100%; margin: 0;&#125; 在根目录创建 gulpfile.js 文件, gulp 执行的文件 123456var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function () &#123; gulp.src(&apos;css/test.css&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;) 多个任务流, 可以限制执行顺序12345678var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, [&apos;css&apos;])gulp.task(&apos;css&apos;,function()&#123; gulp.src(&apos;css/test.css&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;) task 方法可以通过添加参数实现顺序控制 default 执行之前先执行任务 css 将 css 目录下的 test.css 文件重新生成到 dist 目录下 这里 gulp.src 需要处理的文件gulp.dest 输出处理完成的文件 在根目录打开 cmd 或者 git bash 执行命令1$ gulp gulp 会执行默认任务流 default 可以添加参数确保 gulp 执行指定的任务 1$ gulp sass_css 执行指定的任务 sass_css 注意： gulp 命令如果报错 No such file or directory需要全局安装 gulp1$ npm install gulp -g 执行完成后会在根目录多出文件夹 dist 生成新的 test.css 文件 了解基本用法后, 提供几个常见插件的使用 注意： 我这里只是提到常用的几个插件 更多更详细的 看这里 css 插件几个常见的 css 相关插件 sass 编译为 css要实现 sass 的编译使用相关的插件 sass 编译插件 插件名称: gulp-sass 首先需要 安装 gulp-sass 插件1npm install gulp-sass --save 在 css 文件夹下新建文件 main.scss1234$width: 100px;.container&#123; width: $width;&#125; 编译 gulpfile.js 文件12345678var sass = require(&apos;gulp-sass&apos;);// 新建一个任务流 任务流名称可以随意命名gulp.task(&apos;sass_css&apos;, function () &#123; gulp.src(&apos;css/main.scss&apos;) // scss 路径 .pipe(sass()) // 编译 scss .pipe(gulp.dest(&apos;dist&apos;)) // 输出到 dist 文件夹下&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css 执行 gulp 的任务 sass_css会在根目录下生产 dist 文件夹, 以及编译好的 main.css css 文件压缩css 压缩插件 插件名称: gulp-minify-css 安装插件1$ npm install gulp-minify-css --save 修改 gulpfile.js 文件12345678var minifyCss = require(&apos;gulp-minify-css&apos;);// 编译 sass_cssgulp.task(&apos;sass_css_min&apos;, function () &#123; gulp.src(&apos;css/main.scss&apos;) // scss 路径 .pipe(sass()) // 编译 scss .pipe(minifyCss()) // 压缩 css 文件 .pipe(gulp.dest(&apos;dist&apos;)) // 输出到 dist 文件夹下&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_min 这里的压缩会删除不必须的空格以及换行 打开dist内的 main.css 生成的文件内容是一行 css 样式 文件合并文件合并 插件名称: gulp-concat 安装插件1$ npm install gulp-concat --save 在 css 目录下再新建文件 demo.scss12345.demo&#123; width: 100px; height: 100px; background: #2ac3ff;&#125; 修改 gulpfile.js 文件12345678// 编译 sass_css_mingulp.task(&apos;sass_css_concat_min&apos;, function () &#123; gulp.src(&apos;css/*.scss&apos;) // scss 路径 *.scss 适配所有以 scss 结尾的文件 .pipe(sass()) // 编译 scss .pipe(concat(&apos;dist/main.css&apos;)) // concat 需要给合并文件的路劲以及名称 .pipe(minifyCss()) // 压缩 css 文件 .pipe(gulp.dest(&apos;&apos;)) // 输出文件 这里的路劲不需要写 流将 dist/main.css 合并后的文件进行压缩然后输出&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_concat_min 根目录下生成 dist/main.css 会将 main.scss 和 demo.scss 文件内容合并压缩 重命名文件重命名 插件名称: gulp-rename 压缩文件重新命名 添加后缀 .min 安装插件1$ npm install gulp-rename --save 修改 gulpfile.js 文件12345678910var rename = require(&apos;gulp-rename&apos;);// 编译 sass_css_concat_min gulp.task(&apos;sass_css_concat_min_rename&apos;, function () &#123; gulp.src(&apos;css/*.scss&apos;) // scss 路径 *.scss 适配所有以 scss 结尾的文件 .pipe(sass()) // 编译 scss .pipe(concat(&apos;dist/main.css&apos;)) // concat 需要给合并文件的路劲以及名称 .pipe(minifyCss()) // 压缩 css 文件 .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) // 修改压缩文件名称 添加后缀 .min .pipe(gulp.dest(&apos;&apos;)) // 输出文件 这里的路劲不需要写 流将 dist/main.css 合并后的文件进行压缩然后输出&#125;) 根目录打开 cmd 或者 git bash 执行命令1$ gulp sass_css_concat_min_rename 根目录下生成 dist/main.min.css 会将 main.scss 和 demo.scss 文件内容合并压缩 rename 也可以将文件命名为任意名称文档 js 插件压缩插件压缩 js 文件 插件名称: gulp-uglify 用法12345gulp.task(&apos;js_min_ugly&apos;,function () &#123; gulp.src(&apos;js/*/*.js&apos;) // 读取文件 .pipe(uglify()) // 压缩 .pipe(gulp.dest(&apos;dist&apos;)) // 输出&#125;) 注意： 文件压缩插件不支持 es6 需要使用 babel 编译 所以如果使用 es6 语法, 首先需要使用 babel 进行编译 编译插件编译 js 文件为可以被浏览器直接运行的文件 插件名称: gulp-babel123456gulp.task(&apos;js_min_ugly&apos;,function () &#123; gulp.src(&apos;js/*/*.js&apos;) // 读取文件 .pipe(babel(&#123;presets: [&apos;es2015&apos;]&#125;)) // 编译 .pipe(uglify()) // 压缩 压缩不支持 es6 语法,需要使用 babel 编译 .pipe(gulp.dest(&apos;dist&apos;)) // 输出&#125;)]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线图片转 ico]]></title>
    <url>%2F2018%2F08%2F07%2Ficon%2F</url>
    <content type="text"><![CDATA[在线图片转换 ico 地址(https://lvwenhan.com/convertico/) 在线转换器 需要背景透明的小伙伴可以尝试下 IconWorkshop 这个软件只有30天试用期 下载地址 这个倒是十分好用的地址]]></content>
      <tags>
        <tag>ico</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 绑定独立域名]]></title>
    <url>%2F2018%2F08%2F07%2Fdomain%2F</url>
    <content type="text"><![CDATA[github 绑定独立域名 购买域名, 添加解析我的域名从阿里云购买的，以阿里云为例说明流程 在阿里云域名服务购买自己喜欢的域名链接 在阿里云控制台云解析 DNS 添加记录 解析自己的博客地址 三个位置依次选中 CNAME www 博客地址 重复操作添加 CNAME @ 博客地址 使用 github 博客页面可以参考 链接 非阿里云购买的域名解析 控制台域名管理 添加自己购买的域名 在自己购买域名的平台修改 DNS dns12.hichina.com dns11.hichina.com 控制台云解析 DNS 步骤同上 添加 github 重定向在博客根目录下添加文件 CNAME，文件内写入域名注意： 文件没有后缀名 写入内容仅域名地址 例如：kenghuo.ink 或者在 github 仓库 setting 中 Github Page 添加设置 Custom domain 添加域名]]></content>
      <tags>
        <tag>Github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2018%2F08%2F03%2Fworker%2F</url>
    <content type="text"><![CDATA[web worker 的使用 JS 为单线程, 一些计算量较大的代码肯定会影响整体程序的执行速度,而且, 多核计算机的性能也无法高效利用,为了解决这些问题, HTML5 提出 Web Worker , 可以使 JS 一些可以同时进行的事件放在独立的小线程中执行 使用限制在 worker 子线程中，可以获得下列对象 navigator对象 location对象，只读 这里不能进行 location 赋值实现页面跳转！！！ XMLHttpRequest对象 ajax 请求 setTimeout/setInterval方法 Application Cache 通过importScripts()方法加载其他脚本 创建新的Web Worker worker线程不能获得下列对象 DOM对象 window对象 document对象 parent对象 使用主线程使用 new 新建一个子线程, 参数为线程文件Worker1var worker = new Worker(&apos;work.js&apos;); 调用 postMessage 方法向子线程传递消息通过 onmessage 监听子线程发送的消息 onerror 监听错误信息 123456789101112worker.postMessage(&#123;name:&apos;Kenghuo&apos;, title: &apos;Hello&apos;&#125;);worker.onmessage = function(event)&#123; console.log(event); document.getElementById(&apos;title&apos;).innerHTML = event.data;&#125;worker.onerror = function(error)&#123; console.log(error);&#125; 子线程 新建的 work.js 文件 通过 onmessage 来接收主线程发送的消息通过 postMessage 发送处理完成后的信息通过 importScript 引入别的 JS 文件 1234567importScript(&apos;func.js&apos;);onmessage = (event) =&gt; &#123; console.log(event); postMessage(add(event.data.title + &apos; &apos; + event.data.name));&#125; demo]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键分享]]></title>
    <url>%2F2018%2F08%2F02%2Fshare%2F</url>
    <content type="text"><![CDATA[一键分享 一键分享的代码 复制这段代码到希望分享的网页, 即可实现一键分享功能1234567891011121314151617181920212223242526window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: [&quot;tsina&quot;, &quot;weixin&quot;, &quot;mail&quot;, &quot;linkedin&quot;, &quot;copy&quot;, &quot;print&quot;], &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;0&quot;, &quot;bdSize&quot;: &quot;32&quot; &#125;, &quot;slide&quot;: &#123; &quot;type&quot;: &quot;slide&quot;, &quot;bdImg&quot;: &quot;3&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125;&#125;;with(document) 0[ (getElementsByTagName(&apos;head&apos;)[0] || body) .appendChild(createElement(&apos;script&apos;)) .src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];// 这里不支持 with 关键字的代码/* document.getElementsByTagName(&apos;head&apos;)[0].appendChild(document.createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5) */ 注意： JavaScript 严格模式不支持 with 关键字, 需要修改代码 官方百度分享]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 和 github 创建博客最简单粗暴的方法]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo-init%2F</url>
    <content type="text"><![CDATA[在 github 上 使用 hexo 创建博客最简单粗暴的方法 最简单粗暴创建博客的方法 注册账户 注册 github 账号注册地址 新建个人仓库 打开 github page详情见搭建博客 注册账号之后，需要添加SSH Key使用 git 管理代码需要这东西 安装程序 安装 nodejs 下载地址没有特殊要求直接安装一直下一步就行 安装 hexo 在安装 nodeJS 之后，可以使用 npm 包管理器 安装 hexo 1$ npm install hexo hexo-cli -g # 全局安装 hexo 安装 git 下载地址根据需要安装对应版本的 git安装成功之后，右键单击出现 Git Bash Here 以及 Git GUI 说明成功 使用 hexo找个空文件夹直接1$ hexo init 在 hexo init 完成后记得安装包 hexo-deployer-git包1$ npm install hexo-deployer-git --save 修改配置文件 _config.yml123456url: https://github.com/github用户名 # 提交的账户名deploy: type: git repo: https://github.com/github用户名/github用户名.github.io # 提交的仓库 branch: master 配置完成后，依次键入以下命令提交123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo deploy # 提交文件到指定 github 仓库 在本地预览当前博客效果本地123$ hexo clean # 清理原有的文件 public 文件夹$ hexo generate # 重新打包生成 public 文件夹$ hexo server # 开启本地服务器 4000 端口号 浏览器 localhost:4000 可以看到当前博客生成内容]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 常见麻烦]]></title>
    <url>%2F2018%2F07%2F26%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo 使用过程中遇到的麻烦 没反应命令行键入 hexo d 毫无反应 原因: 缺少包 hexo-deployer-git hexo 从版本 2.x.x 升级到 3.x.x 删除了内置的 git 包需要单独安装 hexo-deployer-git 包 原因: 配置文件 url 以及 deploy 未配置123456url: https://github.com/username # 这里是提交的账户deploy: type: git repo: https://github.com/username/username.github.io # 这里是提交仓库的地址 branch: master hexo d 报错可能是 Git 抽风 可以删除根目录下的 .deploy_git 文件夹重新执行 hexo d]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2F2018%2F07%2F26%2Fgit%2F</url>
    <content type="text"><![CDATA[git 常用命令这里总结一些日常工作中使用git管理代码的常用命令对这些命令不感冒的Windows小伙伴也可以使用 git 可视化工具小乌龟下载地址 clone克隆或者叫下载, 将远程服务器上的仓库文件下载到本地 12git clone git@gitee.com:xxx `&lt;dirName&gt;` git clone https://gitee.com/xxx `&lt;dirName&gt;` 将仓库 git@gitee.com:xxx 中的文件下载到本地 ./dirName 目录下将仓库 https://gitee.com/xxx 中的文件下载到本地 ./dirName 目录下 两个命令的区别在于 使用 SSH 下载的内容提交不需要登录名以及密码注意：不论哪个 git 命令提交代码都需要 SSH公匙 验证 SSH Key查看公钥 12$ cd ~/.ssh # 进入指定文件夹 $ ls # 查看文件夹下的文件 存在这两个文件文件1id_rsa id_rsa.pub 文件 id_rsa.pub 储存当前生成的随机数公钥 否则生成公钥1234$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot;$ ssh-keygen -t rsa -C &quot;youremail&quot;连续3个回车 在 github 设置生成的公钥执行命令1ssh git@github.com 出现文字123PTY allocation request failed on channel 0Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 设置公钥成功 push将修改内容交于 git 控制12$ git add . # 提交全部修改的文件$ git add xxx # 提交指定文件 将提交的修改添加到缓冲区1$ git commit -m &apos;xxx&apos; # xxx 提交的注释性内容 上传提交的修改1$ git push origin &lt;branchName&gt; # 提交指定分支的修改 branch 添加分支 git branch &lt;newBranchName&gt; 添加新分支 newBranchName新分支的改动不会影响原有分支的文件 注意切换分支之前对当前分支进行提交 (commit) 操作推送之前注意对应分支, 除了默认分支不需要以外, 其余分支提交 git push origin &lt;branchName&gt; 切换分支 git checkout &lt;branchName&gt; 切换到分支 branchName多个分支之间的文件不受彼此影响 合并分支修改 git merge &lt;branchName&gt; 将当前分支与 branchName 分支合并 resetgit 放弃当前的修改内容 未使用 git add 缓存代码可以使用 git checkout -- filepathname 放弃当前修改注意 该命令中 -- 必不可少用于确保放弃当前修改回退为上次提交内容 已经使用 git add 添加代码到本地缓存可以使用 git reset HEAD filepathname 将指定文件会蹲到上一次提交 已经使用 git commit 提交代码可以使用 git reset --hard HEAD 回退到上次提交内容 其他命令可以参考这里;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F07%2F24%2Fsort%2F</url>
    <content type="text"><![CDATA[几种排序算法 冒泡排序冒泡排序一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 123456789101112131415function bubbleSort(arr) &#123; let len = arr.length; console.time(&apos;原始冒泡排序时间&apos;); for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 let temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.timeEnd(&apos;原始冒泡排序时间&apos;); return arr;&#125; 优化标记已经完成的排序序号, 从未排序的位置开始进行排序, 减少内层循环次数 123456789101112131415161718function bubbleSort2(arr) &#123; let i = arr.length-1; //初始时,最后位置保持不变 console.time(&apos;优化冒泡排序时间&apos;); while ( i&gt; 0) &#123; let pos= 0; // 每趟开始时,无记录交换 for (let j = 0; j&lt; i; j++)&#123; if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 let tmp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; i = pos; // 为下一趟排序作准备 &#125; console.timeEnd(&apos;优化冒泡排序时间&apos;); return arr;&#125; 升级版冒泡排序从前向后同时进行排序操作, 记录排序序号 12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(&apos;2.改进后冒泡排序耗时&apos;); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) &#123; //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) &#123; //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;); return arr3;&#125; 选择排序选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415161718function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); // 计时开始 for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); // 计时结束 return arr;&#125; 插入排序插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 1234567891011121314function insertionSort(array) &#123; console.time(&apos;插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while ( array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时：&apos;); return array;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F07%2F20%2Fblog%2F</url>
    <content type="text"><![CDATA[搭建个人博客的方法 注册github账号注册地址 创建个人仓库登录账户之后 &gt; new repository(注意再次之前需要登录邮箱验证账户) &gt; 进入 Settings 找到 GitHub Pages &gt; choose a theme &gt; 之后再次进入 Settings 在 GitHub Pages 位置多出来 Your site is published at https://kenghuo.github.io/ 表示博客创建成功 点击链接可以进入当前博客 如果想要使用类似 https://kenghuo.github.io/ 这样的域名作为博客地址, 需要仓库名称与账号名称一致 否则的话你的博客地址会变成这样 https://kenghuo.github.io/akang.github.io/ 克隆代码到本地进入已经创建好的个人仓库 有个绿色的按钮 clone and download 可以使用git 或者直接下载压缩包 Download ZIP git clone https://github.com/kenghuo/kenghuo.github.io.git dirname 或者 git clone git@github.com:kenghuo/kenghuo.github.io.git dirname 都可以 dirname 为下载完成的文件夹名称 可以自定义 点击 Download ZIP 下载压缩包 解压缩也可以得到完整的项目 编译博客页面也可以通过HTML可以自定义页面 入口文件名称为 index.html 也可以通过 hexo 搭建页面hexo Github]]></content>
      <tags>
        <tag>Github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 基本语法]]></title>
    <url>%2F2018%2F07%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 语法 Markdown 是一种轻量级标记语言，这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）” 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。 英文参考文献(https://github.com/DavidAnson/markdownlint/blob/v0.10.0/doc/Rules.md)英文参考文献(https://daringfireball.net/projects/markdown/syntax) 中文参考文献(http://www.markdown.cn/)中文参考文献(https://github.com/younghz/Markdown) Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法Markdown 完全支持 HTML 语法 标题同 html h1 ~ h6 文字前加 # 个数表示标题大小, 越少越大(注意一级标题下存在下划线)此外, 一行文本之后添加 = 或者 - 也可以作为一级或者二级标题出现 符号数量任意 123456# 一级标题## 二级标题...###### 六级标题 123456一级标题===二级标题--- 列表有序列表数字加上 .(英文句号) 加个空格 即可构成有序列表数字可以随意写, markdown语法会自动调整为顺序编码 123451. 水果 1. 苹果 1. 香蕉1. 蔬菜1. 小麦 水果 苹果 香蕉 蔬菜 小麦 无序列表* - + . 加个空格 即可构成无序列表同级列表项前的符号保持一致下级子列表 仅需要缩进一格1234567- 测试1 + 测试1.1 * 测试1.1.1 + 测试1.2 + 测试1.3- 测试2- 测试3 测试1 测试1.1 测试1.1.1 测试1.2 测试1.3 测试2 测试3 插入url[ ] ( ) 两个符号构成 [ ] 描述性文字 ( ) 链接地址[ ] 放的是 a 标签里的文字信息 ( ) 路径地址同 html的 a 标签 1234567&lt;a href=&quot;https://www.baidu.com/&quot; title=&quot;类似 html 的title&quot; &gt;百度&lt;/a&gt; [百度](https://www.baidu.com/) 行内式[百度][baidu][baidu]:https://www.baidu.com/ &quot;类似 html 的title&quot; 参考式 可以放在任意位置 比如文本末尾处 效果 百度 百度 百度 插入图片! [ ] ( ) 这三个部分构成图片样式 !是加载图片的标志性符号[ ] 注释性文字 ( ) 图片路径 可以使用相对路径 也可以使用绝对路径 同 html 的 img 标签 12345&lt;img src=&quot;/img/&quot; alt=&quot;百度&quot; /&gt;![狗子](/img/avatar.png)![不存在的图片](#) 效果 粗体、斜体、删除线粗体：在文字前后添加 * 或者 __ (注意符号与文字间不要有空格, 开始标记和结尾标记一致)斜体：在文字前后添加 或者 _删除线：在文字前后添加 ~~ 12345678测试 正常文字样式测试 __粗体文字样式__测试 _斜体文字样式_测试 ~~删除线文字样式~~ 测试 正常文字样式 测试 粗体文字样式 测试 斜体文字样式 测试 删除线文字样式 引用在文字前面加上 &gt;引用支持嵌套 12345&gt; To do or not to do, this is a problem -- Shakespeare&gt; 这里是一级引用 &gt; &gt; 可以在后边嵌套.&gt; &gt; &gt; 甚至可以是多个嵌套等级. To do or not to do, this is a problem – Shakespeare 这里是一级引用 可以在后边嵌套. 甚至可以是多个嵌套等级. 表格两个 | 之间是一个单元格表头与表格主体之间通过 - (任意数量英文减号) 分割分割线单元格数量不少于行内单元格, 比如每行有三个单元格, 分割线大于等于三个行与行之间不要有空行 1234| 姓名 | 地址 | 标题 ||-|-|-|| 阿康 | kenghuo.github.io | markdown || 每行 | 单元格数量一样 | 不然就不是表格了 | 姓名 地址 标题 阿康 kenghuo.github.io markdown 每行 单元格数量一样 不然就不是表格了 代码块12345前后添加 __```__ 注意前边符号写完后需要换行因此可以不换行加上注释性内容, 而不会出现在代码块中 效果如下123for (let i = 0; i &lt; 10; i++)&#123; console.log(&quot;hello markdown!&quot;);&#125; 换行同一段落内换行, 可以在 需要换行的地方 两个空格 回车 段落换行, 需要文字之间出现空行 123456段落内部换行 (两个空格)换行段落1段落2 效果 段落内部换行换行 段落1 段落2]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
